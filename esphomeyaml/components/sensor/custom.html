<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><meta http-equiv="X-UA-Compatible"content="IE=Edge"><meta http-equiv="Content-Type"content="text/html; charset=utf-8"><title>Custom Sensor Component &#8212; esphomelib 1.6.2 documentation</title><link rel="stylesheet"href="../../../_static/alabaster.css"type="text/css"><link rel="stylesheet"href="../../../_static/pygments.css"type="text/css"><script src="../../../_static/documentation_options.js"></script><script src="../../../_static/jquery.js"></script><script src="../../../_static/underscore.js"></script><script src="../../../_static/doctools.js"></script><link rel="index"title="Index"href="../../../genindex.html"><link rel="search"title="Search"href="../../../search.html"><link rel="next"title="Switch Component"href="../switch/index.html"><link rel="prev"title="ESP32 Hall Sensor"href="esp32_hall.html"><link rel="stylesheet"href="../../../_static/custom.css"type="text/css"><meta name="viewport"content="width=device-width,initial-scale=0.9,maximum-scale=0.9"><div class="document"><div class="documentwrapper"><div class="bodywrapper"><div class="body"role="main"><div class="section"id="custom-sensor-component"><h1>Custom Sensor Component<a class="headerlink"href="#custom-sensor-component"title="Permalink to this headline">Â¶</a></h1><div class="admonition warning"><p class="first admonition-title">Warning<p class="last">While I do try to keep the esphomeyaml configuration options as stable as possible and backport them, the esphomelib API is less stable. If something in the APIs needs to be changed in order for something else to work, I will do so.</div><p>So, you just set up esphomelib for your ESP32/ESP8266, but sadly esphomelib is missing a sensor integration youâ€™d really like to have ðŸ˜•. Itâ€™s pretty much impossible to support every single sensor, as there are simply too many. Thatâ€™s why esphomelib has a really simple API for you to create your own <strong>custom sensors</strong> ðŸŽ‰<p>In this guide, we will go through creating a custom sensor component for the <a class="reference external"href="https://www.adafruit.com/product/1603">BMP180</a> pressure sensor (we will only do the pressure part, temperature is more or less the same). During this guide, you will learn how to 1. define a custom sensor esphomelib can use 2. go over how to register the sensor so that it will be shown inside Home Assistant and 3. leverage an existing arduino library for the BMP180 with esphomelib.<div class="admonition note"><p class="first admonition-title">Note<p class="last">Since the creation of this guide, the BMP180 has been officially supported by the <a class="reference internal"href="bmp085.html"><span class="doc">BMP085 component</span></a>. The code still applies though.</div><p>This guide will require at least a bit of knowledge of C++, so be prepared for that. If you have any problems, Iâ€™m here to help :) <a class="reference external"href="https://discord.gg/KhAMKrd">https://discord.gg/KhAMKrd</a><div class="section"id="step-1-custom-sensor-definition"><h2>Step 1: Custom Sensor Definition<a class="headerlink"href="#step-1-custom-sensor-definition"title="Permalink to this headline">Â¶</a></h2><p>At this point, you might have a main source file like this:<div class="code cpp highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="o">...</span>
<span class="n">using</span> <span class="n">namespace</span> <span class="n">esphomelib</span><span class="p">;</span>

<span class="n">void</span> <span class="n">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="o">//</span> <span class="o">=====</span> <span class="n">DO</span> <span class="n">NOT</span> <span class="n">EDIT</span> <span class="n">ANYTHING</span> <span class="n">BELOW</span> <span class="n">THIS</span> <span class="n">LINE</span> <span class="o">=====</span>
  <span class="o">//</span> <span class="o">==========</span> <span class="n">AUTO</span> <span class="n">GENERATED</span> <span class="n">CODE</span> <span class="n">BEGIN</span> <span class="o">===========</span>
  <span class="n">App</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="s2">&quot;livingroom&quot;</span><span class="p">);</span>
  <span class="n">App</span><span class="o">.</span><span class="n">init_log</span><span class="p">();</span>
  <span class="o">//</span> <span class="o">...</span>
  <span class="o">//</span> <span class="o">===========</span> <span class="n">AUTO</span> <span class="n">GENERATED</span> <span class="n">CODE</span> <span class="n">END</span> <span class="o">============</span>
  <span class="o">//</span> <span class="o">=========</span> <span class="n">YOU</span> <span class="n">CAN</span> <span class="n">EDIT</span> <span class="n">AFTER</span> <span class="n">THIS</span> <span class="n">LINE</span> <span class="o">=========</span>
  <span class="n">App</span><span class="o">.</span><span class="n">setup</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">loop</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">App</span><span class="o">.</span><span class="n">loop</span><span class="p">();</span>
<span class="p">}</span>
</pre></div></div><p>To create your own custom sensor, you just have define a C++ class that extends <code class="docutils literal notranslate"><span class="pre">Component</span></code> and <code class="docutils literal notranslate"><span class="pre">Sensor</span></code> like this:<div class="code cpp highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">using</span> <span class="n">namespace</span> <span class="n">esphomelib</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">CustomSensor</span> <span class="p">:</span> <span class="n">public</span> <span class="n">Component</span><span class="p">,</span> <span class="n">public</span> <span class="n">sensor</span><span class="p">::</span><span class="n">Sensor</span> <span class="p">{</span>
 <span class="n">public</span><span class="p">:</span>
  <span class="n">void</span> <span class="n">setup</span><span class="p">()</span> <span class="n">override</span> <span class="p">{</span>
    <span class="o">//</span> <span class="n">This</span> <span class="n">will</span> <span class="n">be</span> <span class="n">called</span> <span class="n">by</span> <span class="n">App</span><span class="o">.</span><span class="n">setup</span><span class="p">()</span>
  <span class="p">}</span>
  <span class="n">void</span> <span class="n">loop</span><span class="p">()</span> <span class="n">override</span> <span class="p">{</span>
    <span class="o">//</span> <span class="n">This</span> <span class="n">will</span> <span class="n">be</span> <span class="n">called</span> <span class="n">by</span> <span class="n">App</span><span class="o">.</span><span class="n">loop</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="n">void</span> <span class="n">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="o">//</span> <span class="o">...</span>
</pre></div></div><p>Youâ€™ve just created your first esphomelib sensor ðŸŽ‰. It doesnâ€™t do very much right now and is never registered, but itâ€™s a first step.<p>Letâ€™s now take a look at how a sensor works in esphomelib: A sensor is some hardware device (like a BMP180) that sends out new values like temperatures.<p>Like any Component in esphomelib, if itâ€™s registered in the Application, <code class="docutils literal notranslate"><span class="pre">setup()</span></code> will be called for you when <code class="docutils literal notranslate"><span class="pre">App.setup()</span></code> is run. <code class="docutils literal notranslate"><span class="pre">setup()</span></code> is also the place where you should do hardware initialization like setting <code class="docutils literal notranslate"><span class="pre">pinMode()</span></code>. Next, every time <code class="docutils literal notranslate"><span class="pre">App.loop()</span></code> is called, your component will also receive a <code class="docutils literal notranslate"><span class="pre">loop()</span></code> call. This is the place where you should do stuff like querying a sensor for a new value like you might be used to do in an Arduino sketch.<p>Letâ€™s now also take a closer look at this line, which you might not be too used to when writing pure C code:<div class="code cpp highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CustomSensor</span> <span class="p">:</span> <span class="n">public</span> <span class="n">Component</span><span class="p">,</span> <span class="n">public</span> <span class="n">sensor</span><span class="p">::</span><span class="n">Sensor</span> <span class="p">{</span>
</pre></div></div><p>What this line is essentially saying is that weâ€™re defining our own class thatâ€™s called <code class="docutils literal notranslate"><span class="pre">CustomSensor</span></code> which is also a subclass of <code class="docutils literal notranslate"><span class="pre">Component</span></code> and <code class="docutils literal notranslate"><span class="pre">Sensor</span></code> (in the namespace <code class="docutils literal notranslate"><span class="pre">sensor::</span></code>). <code class="docutils literal notranslate"><span class="pre">Component</span></code> is there so that we can register it in our application and so that we will receive <code class="docutils literal notranslate"><span class="pre">setup()</span></code> and <code class="docutils literal notranslate"><span class="pre">loop()</span></code> calls. Weâ€™re also inheriting from the <code class="docutils literal notranslate"><span class="pre">Sensor</span></code> class so that our custom sensor can be used by the MQTT sensor to automatically display it in the Home Assistant frontend.<p>As most sensors really just setup some pins and then check the sensor every x seconds, thereâ€™s another abstraction that weâ€™ll use to simplify our code: <code class="docutils literal notranslate"><span class="pre">PollingSensorComponent</span></code>.<div class="code cpp highlight-default notranslate"><div class="highlight"><pre><span></span>class CustomSensor : public sensor::PollingSensorComponent {
 public:
  CustomSensor(uint32_t update_interval) : sensor::PollingSensorComponent(update_interval) {}

  void setup() override {
    // This will be called by App.setup()
  }
  void update() override {
    // This will be called every `update_interval` milliseconds.
  }
};
</pre></div></div><p>What <code class="docutils literal notranslate"><span class="pre">PollingSensorComponent</span></code> (and <code class="docutils literal notranslate"><span class="pre">PollingComponent</span></code>) does is essentially just replace the <code class="docutils literal notranslate"><span class="pre">loop()</span></code> method and will call <code class="docutils literal notranslate"><span class="pre">update()</span></code> instead every <code class="docutils literal notranslate"><span class="pre">update_interval</span></code> milliseconds. Because with most sensors, you really donâ€™t need to get the latest values with every single <code class="docutils literal notranslate"><span class="pre">loop()</span></code> call (which can be called many times per second). If we forward the <code class="docutils literal notranslate"><span class="pre">update_interval</span></code> in our <em>constructor</em> (line 3), <code class="docutils literal notranslate"><span class="pre">PollingSensorComponent</span></code> will call <code class="docutils literal notranslate"><span class="pre">update()</span></code> for us every <code class="docutils literal notranslate"><span class="pre">update_interval</span></code> milliseconds, so that we donâ€™t have to do time checking ourself. You donâ€™t really need to know about constructors for now, but I would definitely recommend it.<p>Letâ€™s also now make our sensor actually <em>output</em> something (42 for now):<div class="code cpp highlight-default notranslate"><div class="highlight"><pre><span></span>// class CustomSensor ...
  // ... previous code
  void update() override {
    push_new_value(42.0);  // 42Â°C
  }

  std::string unit_of_measurement() override { return &quot;Â°C&quot;; }
  int8_t accuracy_decimals() override { return 2; } // 2 decimal places of accuracy.
};
</pre></div></div><p>Every time <code class="docutils literal notranslate"><span class="pre">update</span></code> is called we will now <strong>push</strong> a new value to the MQTT sensor component thatâ€™s listening to our events. Additionally, we created a function that tells the sensor what unit of measurement the value is in, this is not strictly required and only used for a nice output in Home Assistant.</div><div class="section"id="step-2-registering-the-custom-sensor"><h2>Step 2: Registering the custom sensor<a class="headerlink"href="#step-2-registering-the-custom-sensor"title="Permalink to this headline">Â¶</a></h2><p>Now we have our Custom Sensor set up, but unfortunately it doesnâ€™t do much right now. Actually â€¦ it does nothing because itâ€™s never registered in the App, so esphomelib canâ€™t know about it. Letâ€™s change that.<p>In your global <code class="docutils literal notranslate"><span class="pre">setup()</span></code> method, after youâ€™ve setup all other components, do the following:<div class="code cpp highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="o">//</span> <span class="o">...</span>
  <span class="n">App</span><span class="o">.</span><span class="n">init_mqtt</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>

  <span class="o">//</span> <span class="o">...</span> <span class="n">other</span> <span class="n">stuff</span>

  <span class="n">auto</span> <span class="o">*</span><span class="n">custom_sensor</span> <span class="o">=</span> <span class="n">new</span> <span class="n">CustomSensor</span><span class="p">(</span><span class="mi">5000</span><span class="p">);</span> <span class="o">//</span> <span class="n">update</span> <span class="n">every</span> <span class="mi">5000</span><span class="n">ms</span> <span class="ow">or</span> <span class="n">every</span> <span class="mi">5</span> <span class="n">seconds</span><span class="o">.</span>
  <span class="n">App</span><span class="o">.</span><span class="n">register_component</span><span class="p">(</span><span class="n">custom_sensor</span><span class="p">);</span>
  <span class="n">App</span><span class="o">.</span><span class="n">make_mqtt_sensor_for</span><span class="p">(</span><span class="n">custom_sensor</span><span class="p">,</span> <span class="s2">&quot;Custom Sensor Example&quot;</span><span class="p">);</span>

  <span class="n">App</span><span class="o">.</span><span class="n">setup</span><span class="p">();</span>
<span class="p">}</span>
</pre></div></div><p>If you have Home Assistant MQTT discovery setup, it will even automatically show up in the frontend ðŸŽ‰ (with the entity id <code class="docutils literal notranslate"><span class="pre">sensor.custom_sensor_example</span></code>)<div class="figure align-center"><a class="reference internal image-reference"href="../../../_images/custom-ui.png"><img alt="../../../_images/custom-ui.png"src="../../../_images/custom-ui.png"style="width: 60%;"></a></div><p>Letâ€™s go through the code for registering our custom sensor. First, weâ€™re creating a new CustomSensor instance with the update interval of 5000ms using the <code class="docutils literal notranslate"><span class="pre">new</span></code> C++ syntax (important!) and assigning it to a variable <code class="docutils literal notranslate"><span class="pre">custom_sensor</span></code> (using C++11 <code class="docutils literal notranslate"><span class="pre">auto</span></code> type specifier to make it simpler).<div class="code cpp highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">auto</span> <span class="o">*</span><span class="n">custom_sensor</span> <span class="o">=</span> <span class="n">new</span> <span class="n">CustomSensor</span><span class="p">(</span><span class="mi">5000</span><span class="p">);</span>
</pre></div></div><p>Next, we <em>register</em> the component in esphomelibâ€™s Application instance so that it can call the componentâ€™s <code class="docutils literal notranslate"><span class="pre">setup()</span></code> and <code class="docutils literal notranslate"><span class="pre">loop()</span></code>.<div class="code cpp highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">App</span><span class="o">.</span><span class="n">register_component</span><span class="p">(</span><span class="n">custom_sensor</span><span class="p">);</span>

<span class="o">//</span> <span class="n">you</span> <span class="n">could</span> <span class="n">also</span> <span class="n">write</span> <span class="n">this</span><span class="p">,</span> <span class="n">it</span><span class="s1">&#39;s a bit shorter and works the same way.</span>
<span class="o">//</span> <span class="n">auto</span> <span class="o">*</span><span class="n">custom_sensor</span> <span class="o">=</span> <span class="n">App</span><span class="o">.</span><span class="n">register_component</span><span class="p">(</span><span class="n">new</span> <span class="n">CustomSensor</span><span class="p">(</span><span class="mi">5000</span><span class="p">));</span>
</pre></div></div><p>Lastly, weâ€™re setting up a <code class="docutils literal notranslate"><span class="pre">MQTTSensorComponent</span></code> for our sensor, this mqtt component will automatically set up a bunch of callbacks so that it can publish state changes to MQTT when you call <code class="docutils literal notranslate"><span class="pre">publish_new_value()</span></code>, create automatic MQTT discovery messages and setup a moving average over the sensor values (adjust these as you would with any other sensor).</div><div class="section"id="step-3-bmp180-support"><h2>Step 3: BMP180 support<a class="headerlink"href="#step-3-bmp180-support"title="Permalink to this headline">Â¶</a></h2><p>Letâ€™s finally make this custom sensor useful by adding the BMP180 aspect into it! A great feature of esphomelib is that you can just use all existing arduino libraries, amazing right? Now for this example weâ€™ll use the <a class="reference external"href="https://platformio.org/lib/show/525/Adafruit%20BMP085%20Library">Adafruit BMP085 Library</a> library by Adafruit.<p>First weâ€™ll need to add the library to our platformio dependencies. To do so, put the following in the <code class="docutils literal notranslate"><span class="pre">common</span></code> section of your <code class="docutils literal notranslate"><span class="pre">platformio.ini</span></code>:<div class="code ini highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">common</span><span class="p">]</span>
<span class="n">lib_deps</span> <span class="o">=</span> <span class="n">Adafruit</span> <span class="n">BMP085</span> <span class="n">Library</span>
<span class="n">build_flags</span> <span class="o">=</span>
<span class="n">upload_flags</span> <span class="o">=</span>
</pre></div></div><p>Next, include the library in your main sketch file:<div class="code cpp highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &quot;esphomelib/application.h&quot;</span>
<span class="c1">#include &lt;Adafruit_BMP085.h&gt;</span>

<span class="n">using</span> <span class="n">namespace</span> <span class="n">esphomelib</span><span class="p">;</span>
</pre></div></div><p>Then update our sensor for BMP180 support:<div class="code cpp highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">BMP180Sensor</span> <span class="p">:</span> <span class="n">public</span> <span class="n">sensor</span><span class="p">::</span><span class="n">PollingSensorComponent</span> <span class="p">{</span>
 <span class="n">public</span><span class="p">:</span>
  <span class="n">Adafruit_BMP085</span> <span class="n">bmp</span><span class="p">;</span>

  <span class="n">BMP180Sensor</span><span class="p">(</span><span class="n">uint32_t</span> <span class="n">update_interval</span><span class="p">)</span> <span class="p">:</span> <span class="n">sensor</span><span class="p">::</span><span class="n">PollingSensorComponent</span><span class="p">(</span><span class="n">update_interval</span><span class="p">)</span> <span class="p">{}</span>

  <span class="n">void</span> <span class="n">setup</span><span class="p">()</span> <span class="n">override</span> <span class="p">{</span>
    <span class="n">bmp</span><span class="o">.</span><span class="n">begin</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">void</span> <span class="n">update</span><span class="p">()</span> <span class="n">override</span> <span class="p">{</span>
    <span class="nb">int</span> <span class="n">pressure</span> <span class="o">=</span> <span class="n">bmp</span><span class="o">.</span><span class="n">readPressure</span><span class="p">();</span> <span class="o">//</span> <span class="ow">in</span> <span class="n">Pa</span><span class="p">,</span> <span class="ow">or</span> <span class="mi">1</span><span class="o">/</span><span class="mi">100</span> <span class="n">hPa</span>
    <span class="n">push_new_value</span><span class="p">(</span><span class="n">pressure</span> <span class="o">/</span> <span class="mf">100.0</span><span class="p">);</span> <span class="o">//</span> <span class="n">convert</span> <span class="n">to</span> <span class="n">hPa</span>
  <span class="p">}</span>

  <span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="n">unit_of_measurement</span><span class="p">()</span> <span class="n">override</span> <span class="p">{</span> <span class="k">return</span> <span class="s2">&quot;hPa&quot;</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">int8_t</span> <span class="n">accuracy_decimals</span><span class="p">()</span> <span class="n">override</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">2</span><span class="p">;</span> <span class="p">}</span> <span class="o">//</span> <span class="mi">2</span> <span class="n">decimal</span> <span class="n">places</span> <span class="n">of</span> <span class="n">accuracy</span><span class="o">.</span>
<span class="p">};</span>
</pre></div></div><p>Thereâ€™s not too much going on there. First, we define the variable <code class="docutils literal notranslate"><span class="pre">bmp</span></code> of type <code class="docutils literal notranslate"><span class="pre">Adafruit_BMP085</span></code> inside our class as a class member. In <code class="docutils literal notranslate"><span class="pre">setup()</span></code> we initialize the library and in <code class="docutils literal notranslate"><span class="pre">update()</span></code> we read the pressure and send it out to MQTT.<p>Youâ€™ve now successfully created your first custom sensor component ðŸŽ‰ Happy coding!</div><div class="section"id="see-also"><h2>See Also<a class="headerlink"href="#see-also"title="Permalink to this headline">Â¶</a></h2><ul class="simple"><li><a class="reference external"href="https://github.com/OttoWinter/esphomelib/blob/master/examples/custom-bmp180-sensor.cpp">Full source code</a><li><a class="reference external"href="https://github.com/OttoWinter/esphomedocs/blob/current/esphomeyaml/components/sensor/custom.rst">Edit this page on GitHub</a></ul></div></div></div></div></div><div class="sphinxsidebar"role="navigation"aria-label="main navigation"><div class="sphinxsidebarwrapper"><div class="relations"><h3>Related Topics</h3><ul><li><a href="../../../index.html">Documentation overview</a><ul><li><a href="../../index.html">esphomeyaml</a><ul><li><a href="../index.html">Components</a><ul><li><a href="index.html">Sensor Component</a><ul><li>Previous: <a href="esp32_hall.html"title="previous chapter">ESP32 Hall Sensor</a><li>Next: <a href="../switch/index.html"title="next chapter">Switch Component</a></ul></ul></ul></ul></ul></div><div id="searchbox"style="display: none"role="search"><h3>Quick search</h3><div class="searchformwrapper"><form class="search"action="../../../search.html"><input name="q"> <input type="submit"value="Go"> <input type="hidden"name="check_keywords"value="yes"> <input type="hidden"name="area"value="default"></form></div></div><script>$('#searchbox').show(0);</script></div></div><div class="clearer"></div></div><div class="footer">&copy;2018, Otto Winter. | Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.2</a> &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a> | <a href="../../../_sources/esphomeyaml/components/sensor/custom.rst.txt"rel="nofollow">Page source</a></div>