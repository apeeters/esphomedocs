<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><meta http-equiv="X-UA-Compatible"content="IE=Edge"><meta http-equiv="Content-Type"content="text/html; charset=utf-8"><title>Web Server API &#8212; esphomelib 1.6.2 documentation</title><link rel="stylesheet"href="../_static/alabaster.css"type="text/css"><link rel="stylesheet"href="../_static/pygments.css"type="text/css"><script src="../_static/documentation_options.js"></script><script src="../_static/jquery.js"></script><script src="../_static/underscore.js"></script><script src="../_static/doctools.js"></script><link rel="index"title="Index"href="../genindex.html"><link rel="search"title="Search"href="../search.html"><link rel="next"title="API Reference"href="../api/index.html"><link rel="prev"title="Contributing"href="../esphomeyaml/guides/contributing.html"><link rel="stylesheet"href="../_static/custom.css"type="text/css"><meta name="viewport"content="width=device-width,initial-scale=0.9,maximum-scale=0.9"><div class="document"><div class="documentwrapper"><div class="bodywrapper"><div class="body"role="main"><div class="section"id="web-server-api"><h1>Web Server API<a class="headerlink"href="#web-server-api"title="Permalink to this headline">¶</a></h1><p>Since version 1.3, esphomelib includes a built-in web server that can be used to view states and send commands. In addition to visible the web-frontend available under the root index of the web server, there’s also two other features the web server currently offers: A real time event source and REST API.<p>Note that the web server is only and will only ever be intended to view and edit states. Specifically not something like configuring the node, as that would quickly blow up the required flash and memory size.<p>First up, to use the web server enable it using <code class="docutils literal notranslate"><span class="pre">App.init_web_server()</span></code> directly from code or using the <a class="reference internal"href="../esphomeyaml/components/web_server.html"><span class="doc">Web Server Section</span></a> in esphomeyaml. Then, navigate to the front end interface with the IP of the node or alternatively using mDNS with <code class="docutils literal notranslate"><span class="pre">&lt;name&gt;.local/</span></code>. So for example to navigate to the web server of a node called <code class="docutils literal notranslate"><span class="pre">livingroom</span></code>, you would enter <code class="docutils literal notranslate"><span class="pre">livingroom.local/</span></code> in your browser.<p>While it’s currently recommended to use esphomelib directly through Home Assistant, if you want to integrate esphomelib with an external or self-built application you can use two available APIs: the real-time event source API and REST API.<div class="section"id="event-source-api"><h2>Event Source API<a class="headerlink"href="#event-source-api"title="Permalink to this headline">¶</a></h2><p>If you want to receive real-time updates for sensor state updates, it’s recommended to use the Event Source Web API. With the URL <code class="docutils literal notranslate"><span class="pre">/events</span></code>, you can create an <a class="reference external"href="https://developer.mozilla.org/en-US/docs/Web/API/EventSource">Event Source</a> that receives real-time updates of states and the debug log using server-sent events. Event sources are easy to implement in many languages and already have many libraries available. For example <a class="reference external"href="https://github.com/EventSource/eventsource">eventsource for node.js</a> and <a class="reference external"href="https://pypi.org/project/eventsource/1.1.1/">eventsource for python</a>.<p>Currently, there are three types of events sent: <code class="docutils literal notranslate"><span class="pre">ping</span></code>, <code class="docutils literal notranslate"><span class="pre">state</span></code> and <code class="docutils literal notranslate"><span class="pre">log</span></code>. The first one is repeatedly sent out to keep the connection alive. <code class="docutils literal notranslate"><span class="pre">log</span></code> events are sent every time a log message is triggered and is used to show the debug log on the index page. <code class="docutils literal notranslate"><span class="pre">state</span></code> is where the real magic happens. All events with this type have a JSON payload that describes the state of a component. Each of these JSON payloads have two mandatory fields: <code class="docutils literal notranslate"><span class="pre">id</span></code> and <code class="docutils literal notranslate"><span class="pre">state</span></code>. ID is the unique identifier of the component and is prefixed with the domain of the component, for example <code class="docutils literal notranslate"><span class="pre">sensor</span></code>. <code class="docutils literal notranslate"><span class="pre">state</span></code> contains a simple text-based representation of the state of the underlying component, for example ON/OFF or 21.4 °C. Several components also have additional fields in this payload, for example lights have a <code class="docutils literal notranslate"><span class="pre">brightness</span></code> attribute.<div class="figure align-center"id="id1"><img alt="../_images/event-source.png"src="../_images/event-source.png"><p class="caption"><span class="caption-text">Example payload of the event source API.</span></div><p>Additionally, each time a client connects to the event source the server sends out all current states so that the client can catch up with reality.<p>The payloads of these state events are also the same as the payloads of the REST API GET calls. I would recommend just opening the network debug panel of your web browser to see what’s sent.<div class="section"id="rest-api"><h3>REST API<a class="headerlink"href="#rest-api"title="Permalink to this headline">¶</a></h3><p>There’s also a simple REST API available which can be used to get and set the current state. All calls to this API follow the URL schema <code class="docutils literal notranslate"><span class="pre">/&lt;domain&gt;/&lt;id&gt;[/&lt;method&gt;?&lt;param&gt;=&lt;value&gt;]</span></code>. The <code class="docutils literal notranslate"><span class="pre">domain</span></code> is the type of the component, for example <code class="docutils literal notranslate"><span class="pre">sensor</span></code> or <code class="docutils literal notranslate"><span class="pre">light</span></code>. <code class="docutils literal notranslate"><span class="pre">id</span></code> refers to the id of the component - this ID is created by taking the name of the component, stripping out all non-alphanumeric characters, making everything lowercase and replacing all spaces by underscores.<p>By creating a simple GET request for a URL of the form <code class="docutils literal notranslate"><span class="pre">/&lt;domain&gt;/&lt;id&gt;</span></code> you will get a JSON payload describing the current state of the component. This payload is equivalent to the ones sent by the event source API.<p>To actually <em>control</em> the state of a component you need to send a POST request with a <code class="docutils literal notranslate"><span class="pre">method</span></code> like <code class="docutils literal notranslate"><span class="pre">turn_on</span></code>. For example, to turn on a light, you would send a POST request to <code class="docutils literal notranslate"><span class="pre">/light/livingroom_lights/turn_on</span></code>. Some components also optionally accept URL parameters to control some other aspects of a component, for example the brightness of a light.<div class="section"id="sensor"><h4>Sensor<a class="headerlink"href="#sensor"title="Permalink to this headline">¶</a></h4><p>Sensors only support GET requests by sending a request to <code class="docutils literal notranslate"><span class="pre">/sensor/&lt;id&gt;</span></code>. For example sending a GET request to <code class="docutils literal notranslate"><span class="pre">/sensor/outside_temperature</span></code> could yield this payload:<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;id&quot;</span><span class="p">:</span> <span class="s2">&quot;sensor-outside_temperature&quot;</span><span class="p">,</span>
  <span class="nt">&quot;state&quot;</span><span class="p">:</span> <span class="s2">&quot;19.8 °C&quot;</span><span class="p">,</span>
  <span class="nt">&quot;value&quot;</span><span class="p">:</span> <span class="mf">19.76666</span>
<span class="p">}</span>
</pre></div></div><ul class="simple"><li><strong>id</strong>: The id of the sensor. Prefixed by <code class="docutils literal notranslate"><span class="pre">sensor-</span></code>.<li><strong>state</strong>: The text-based state of the sensor as a string.<li><strong>value</strong>: The floating point (filtered) value of the sensor.</ul></div><div class="section"id="binary-sensor"><h4>Binary Sensor<a class="headerlink"href="#binary-sensor"title="Permalink to this headline">¶</a></h4><p>Binary sensors have a similar payload and also only support GET requests. For example requesting the current state of a binary sensor using the URL <code class="docutils literal notranslate"><span class="pre">binary_sensor/living_room_status</span></code> could result in following payload:<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;id&quot;</span><span class="p">:</span> <span class="s2">&quot;binary_sensor-living_room_status&quot;</span><span class="p">,</span>
  <span class="nt">&quot;state&quot;</span><span class="p">:</span> <span class="s2">&quot;ON&quot;</span><span class="p">,</span>
  <span class="nt">&quot;value&quot;</span><span class="p">:</span> <span class="kc">true</span>
<span class="p">}</span>
</pre></div></div><ul class="simple"><li><strong>id</strong>: The id of the binary sensor. Prefixed by <code class="docutils literal notranslate"><span class="pre">binary_sensor-</span></code>.<li><strong>state</strong>: The text-based state of the binary sensor as a string.<li><strong>value</strong>: The binary (<code class="docutils literal notranslate"><span class="pre">true</span></code>/<code class="docutils literal notranslate"><span class="pre">false</span></code>) state of the binary sensor.</ul></div><div class="section"id="switch"><h4>Switch<a class="headerlink"href="#switch"title="Permalink to this headline">¶</a></h4><p>Switches have the exact same properties as a binary sensor in the state reporting aspect, but they additionally support setting states with the <code class="docutils literal notranslate"><span class="pre">turn_on</span></code>, <code class="docutils literal notranslate"><span class="pre">turn_off</span></code> and <code class="docutils literal notranslate"><span class="pre">toggle</span></code> methods.<p>Each of these is quite self explanatory. Creating a POST request to <code class="docutils literal notranslate"><span class="pre">/switch/dehumidifer/turn_on</span></code> would for example result in the component called “Dehumidifer” to be turned on. The server will respond with a 200 OK HTTP return code if the call succeeded.</div><div class="section"id="light"><h4>Light<a class="headerlink"href="#light"title="Permalink to this headline">¶</a></h4><p>Lights support quite a few more complicated options, like brightness or color. But first, to get the state of a light, send a GET request to <code class="docutils literal notranslate"><span class="pre">/light/&lt;id&gt;</span></code>, for example <code class="docutils literal notranslate"><span class="pre">light/living_room_lights</span></code>.<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;id&quot;</span><span class="p">:</span> <span class="s2">&quot;light-living_room_lights&quot;</span><span class="p">,</span>
  <span class="nt">&quot;state&quot;</span><span class="p">:</span> <span class="s2">&quot;ON&quot;</span><span class="p">,</span>
  <span class="nt">&quot;brightness&quot;</span><span class="p">:</span> <span class="mi">255</span><span class="p">,</span>
  <span class="nt">&quot;color&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;r&quot;</span><span class="p">:</span> <span class="mi">255</span><span class="p">,</span>
    <span class="nt">&quot;g&quot;</span><span class="p">:</span> <span class="mi">255</span><span class="p">,</span>
    <span class="nt">&quot;b&quot;</span><span class="p">:</span> <span class="mi">255</span>
  <span class="p">},</span>
  <span class="nt">&quot;effect&quot;</span><span class="p">:</span> <span class="s2">&quot;None&quot;</span><span class="p">,</span>
  <span class="nt">&quot;white_value&quot;</span><span class="p">:</span> <span class="mi">255</span>
<span class="p">}</span>
</pre></div></div><ul class="simple"><li><strong>id</strong>: The id of the light. Prefixed by <code class="docutils literal notranslate"><span class="pre">light-</span></code>.<li><strong>state</strong>: The text-based state of the light as a string.<li><strong>brightness</strong>: The brightness of the light from 0 to 255. Only if the light supports brightness. If <code class="docutils literal notranslate"><span class="pre">state</span></code> is <code class="docutils literal notranslate"><span class="pre">OFF</span></code>, this can still report values like 255 in order to send the full state.<li><strong>color</strong>: The color of this light, only if it supports color.<ul><li><strong>r</strong>: The red channel of this light. From 0 to 255.<li><strong>g</strong>: The green channel of this light. From 0 to 255.<li><strong>b</strong>: The blue channel of this light. From 0 to 255.</ul><li><strong>effect</strong>: The currently active effect, only if the light supports effects.<li><strong>white_value</strong>: The white value of RGBW lights. From 0 to 255.</ul><p>Setting light state can happen through three POST method calls: <code class="docutils literal notranslate"><span class="pre">turn_on</span></code>, <code class="docutils literal notranslate"><span class="pre">turn_off</span></code> and <code class="docutils literal notranslate"><span class="pre">toggle</span></code>. Turn on and off have additional URL encoded parameters that can be used to set other properties. For example creating a POST request at <code class="docutils literal notranslate"><span class="pre">/light/&lt;id&gt;/turn_on?brightness=128&amp;transition=2</span></code> will create transition with length 2s to the brightness 128 while retaining the color of the light.<p><code class="docutils literal notranslate"><span class="pre">turn_on</span></code> optional URL parameters:<ul class="simple"><li><strong>brightness</strong>: The brightness of the light, from 0 to 255.<li><strong>r</strong>: The red color channel of the light, from 0 to 255.<li><strong>g</strong>: The green color channel of the light, from 0 to 255.<li><strong>b</strong>: The blue color channel of the light, from 0 to 255.<li><strong>white_value</strong>: The white channel of RGBW lights, from 0 to 255.<li><strong>flash</strong>: Flash the color provided by the other properties for a duration in seconds.<li><strong>transition</strong>: Transition to the specified color values in this duration in seconds.<li><strong>effect</strong>: Set an effect for the light.</ul><p><code class="docutils literal notranslate"><span class="pre">turn_off</span></code> optional URL parameters:<ul class="simple"><li><strong>transition</strong>: Transition to off in this duration in seconds.</ul></div><div class="section"id="fan"><h4>Fan<a class="headerlink"href="#fan"title="Permalink to this headline">¶</a></h4><p>Fans are similar to switches as they can be turned on/off and toggled. In addition, if the underlying fan supports it, fans in the web server also support the speed settings “low”, “medium” and “high” and an oscillation setting. To get the current state of a fan, create a GET request to <code class="docutils literal notranslate"><span class="pre">/fan/&lt;id&gt;</span></code>.<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;id&quot;</span><span class="p">:</span> <span class="s2">&quot;fan-living_room_fan&quot;</span><span class="p">,</span>
  <span class="nt">&quot;state&quot;</span><span class="p">:</span> <span class="s2">&quot;ON&quot;</span><span class="p">,</span>
  <span class="nt">&quot;value&quot;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="nt">&quot;speed&quot;</span><span class="p">:</span> <span class="s2">&quot;high&quot;</span><span class="p">,</span>
  <span class="nt">&quot;oscillation&quot;</span><span class="p">:</span> <span class="kc">false</span>
<span class="p">}</span>
</pre></div></div><ul class="simple"><li><strong>id</strong>: The id of the fan. Prefixed by <code class="docutils literal notranslate"><span class="pre">fan-</span></code>.<li><strong>state</strong>: The text-based state of the fan as a string.<li><strong>value</strong>: The binary (<code class="docutils literal notranslate"><span class="pre">true</span></code>/<code class="docutils literal notranslate"><span class="pre">false</span></code>) state of the fan.<li><strong>speed</strong>: The speed setting of the fan if it’s supported. Either “off”, “low”, “medium” or “high”.<li><strong>oscillation</strong>: Whether the oscillation setting of the fan is on. Only sent if the fan supports it.</ul><p>To control the state of the fan, send POST requests to <code class="docutils literal notranslate"><span class="pre">/fan/&lt;id&gt;/turn_on</span></code>, <code class="docutils literal notranslate"><span class="pre">/fan/&lt;id&gt;/turn_off</span></code> and <code class="docutils literal notranslate"><span class="pre">/fan/&lt;id&gt;/toggle</span></code>. Turn on additionally supports these optional parameters:<ul class="simple"><li><strong>speed</strong>: The new speed setting of the fan. Values as above.<li><strong>oscillation</strong>: The new oscillation setting of the fan. Values as above.</ul></div></div></div></div></div></div></div><div class="sphinxsidebar"role="navigation"aria-label="main navigation"><div class="sphinxsidebarwrapper"><div class="relations"><h3>Related Topics</h3><ul><li><a href="../index.html">Documentation overview</a><ul><li>Previous: <a href="../esphomeyaml/guides/contributing.html"title="previous chapter">Contributing</a><li>Next: <a href="../api/index.html"title="next chapter">API Reference</a></ul></ul></div><div id="searchbox"style="display: none"role="search"><h3>Quick search</h3><div class="searchformwrapper"><form class="search"action="../search.html"><input name="q"> <input type="submit"value="Go"> <input type="hidden"name="check_keywords"value="yes"> <input type="hidden"name="area"value="default"></form></div></div><script>$('#searchbox').show(0);</script></div></div><div class="clearer"></div></div><div class="footer">&copy;2018, Otto Winter. | Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.2</a> &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a> | <a href="../_sources/web-api/index.rst.txt"rel="nofollow">Page source</a></div>